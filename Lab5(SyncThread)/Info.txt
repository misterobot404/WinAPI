
 Три потока генерируют случайные числа в диапазоне от 0 до 1000. 
 Если в потоке число попадется больше 900,  поток выводит на экран (в случайном месте) окно, 
 в котором непрерывно создаются одним потоком - закрашенные окружности случайных радиусов, 
 другим потоком – прямоугольники, а третьим – треугольники. Одновременно на экране может быть не более пяти окон. 
 Пользователь может закрыть одно из них. Тут же появляется другое.
 
	 Использование событий
Если событие будет использоваться потоками одного процесса, вы можете не присваивать этому событию имя. Чтобы создать событие, обратитесь к вызову CreateEvent и передайте ему четыре аргумента. Первый аргумент — атрибуты без-опасности. Если вы намерены использовать атрибуты по умолчанию, присвойте этому аргументу значение NULL. Второй аргумент определяет тип события (мануалъное — manual или единичное — single), а третий аргумент соответствует на¬чальному состоя-нию события. Наконец, последний аргумент соответствует име¬ни события. Если вы хотите создать безымянное событие, передайте в качестве этого аргумента значение NULL.
Если вы хотите, чтобы к событию смогли обратиться другие процессы, вы должны присвоить этому событию уникальное имя. Имя не может содержать символов обратной косой. При именовании событий необходимо учитывать ре¬гистр символов. Вызов CreateEvent создает событие с указанным именем в слу¬чае, если такого собы-тия еще не создано в системе. Если событие с указанным именем уже существует, вы-зов CreateEvent просто открывает существующее со¬бытие. В любом случае этот вызов возвращает вызвавшему процессу дескриптор события.
Чтобы определить состояние события, вы можете обратиться к любой из функ-ций слежения за состоянием объектов синхронизации (например, WaitForSingleObject). Более подробно об этом рассказано несколько ранее, в раз¬деле «Выбор метода синхро-низации».
Чтобы перевести событие в сигнальное состояние, необходимо использовать вызовы SetEvent или PulseEvent. Вызов PulseEvent переводит событие в сигналь¬ное состояние на период времени, пока все ожидающие это событие потоки не прореаги-руют на него. После этого событие автоматически сбрасывается. Единич¬ное событие остается в сигнальном состоянии до того момента, пока на него не прореагирует один из ожидающих потоков. После этого единичное событие ав¬томатически сбрасывается. Мануальное событие остается в сигнальном состоя¬нии до тех пор, пока не произойдет обращение к функции ResetEvent. Чтобы закрыть событие, в котором вы больше не нуждаетесь, необходимо обратиться к функции CloseHandle. Простой пример исполь-зования событий приведен в лис¬тинге 1.

	Использование мьютексов
Вызов CreateMutex предназначен для создания нового мьютекса, а вызов OpenMutex — для открытия уже существующего мьютекса. Как и в случае с другими объекта¬ми синхронизации, если вы хотите, чтобы мьютекс использовался несколькими разными процессами, вы должны присвоить мьютексу имя. Вызов CreateMutex при-нимает в качестве аргументов атрибуты безопасности (обычно NULL), флаг, опреде-ляющий, будет ли мьютекс изначально принадлежать потоку, который его создает, и имя мьютекса, которое можно не указывать.
Если поток желает завладеть мьютексом, он должен обратиться к одной из функций ожидания объекта синхронизации (например, WaitForSingleObject). Если вызов функции завершается успехом, вызвавший ее поток становится обладате¬лем мьютекса. Поток, владеющий мьютексом, может завладеть им повторно. Од¬нако дру-гие потоки, пытающиеся завладеть мьютексом, будут вынуждены ожи¬дать до тех пор, пока поток-владелец не освободит мьютекс.
Чтобы освободить мьютекс, поток-владелец должен обратиться к функции ReleaseMutex. Если ранее поток завладел мьютексом несколько раз (то есть, напри¬мер, этот поток несколько раз обращался к функции WaitForSingleObject в отно¬шении од-ного и того же мьютекса), чтобы освободить мьютекс, поток должен обратиться к ReleaseMutex точно такое же количество раз. Если мьютекс больше не нужен, про-грамма должна обратиться к вызову CloseHandle для того, чтобы закрыть мьютекс. Пример программы, использующей мьютекс, приведен в лис¬тинге 2.

	Использование критических секций
Критические секции работают приблизительно так же, как мыотексы, однако их нельзя использовать для синхронизации работы нескольких процессов. Крити¬ческая секция ограничивает доступ к некоторому участку кода для нескольких потоков, при-надлежащих одному и тому же процессу. Конечно, это ограничивает область исполь-зования критических секций, однако критические секции работа¬ют быстрее, чем мыотексы.
Чтобы использовать критическую секцию, необходимо создать в глобальной памяти переменную CRITICAL_SECTION. После этого программа должна один раз обратиться к функции InitializeCriticalSection. В начале участка кода, доступ к которо-му требуется ограничить, необходимо разместить обращение к функции EnterCriticalSection. В конце критического участка кода следует разместить об-ращение к функции LeaveCriticalSection. После того как один из потоков обра¬тится к функции EnterCriticalSection, выполнение остальных потоков, обращаю¬щихся к этой функции, будет блокировано. Как только поток, выполняющий критический участок кода, обратится к вызову LeaveCriticalSection, один из по¬токов, блокированных вызо-вом EnterCriticalSection, сможет продолжить работу. Если в момент обращения потока к LeaveCriticalSection ни один другой поток не ожидает освобождения критической секции, следующий поток, обратившийся к
 EnterCnticalSection, сможет успешно приступить к выполнению критического участка кода,
Состояние критической секции можно проверить при помощи вызова TryCriticalSection. Если вызов вернул значение «истина», значит, критический уча-сток свободен, и поток может приступить к его выполнению. Если вызов TryCriticalSection вернул значение «ложь», критическая секция уже занята, и поток должен подождать некоторое время, а потом еще раз проверить, можно ли ей завла-деть. Ожидая освобождения критической секции, поток может выполнять ка¬кую-либо другую полезную работу.

	Использование семафоров
Так же как и мьютексы, семафоры служат для ограничения одновременного дос-тупа к ресурсу нескольких потоков. В любой момент времени мьютекс разрешает доступ к ресурсу только для одного потока. Используя семафор, вы можете организовать работу программы таким образом, что к ресурсу одновременно смо¬гут получить до-ступ несколько потоков, однако количество этих потоков будет ограничено. Создавая семафор, вы указываете максимальное количество пото¬ков, которые одновременно смогут работать с ресурсом. Если в некоторый момент времени с ресурсом работает меньшее количество потоков, семафор ос¬тается в сигнальном состоянии. Как только количество потоков, желающих ра¬ботать с ресурсом, становится больше допустимого, семафор блокирует доступ к семафору.
Для работы с семафором служат вызовы CreateSemaphore и OpenSemaphore. Как и в других случаях, вызов CreateSemaphore либо создает новый семафор с указан-ным именем или открывает уже существующий семафор. Вызов OpenSemaphore сра-батывает только в случае, если семафор с указанным именем уже существует.
При создании семафора необходимо указать атрибуты безопасности, начальное значение счетчика, максимальное допустимое значение счетчика и имя (ко¬торое можно не указывать). Обращение к семафору со стороны какого-либо по¬тока уменьшает зна-чение счетчика на единицу. Как только значение счетчика становится равным нулю, семафор блокирует доступ к ресурсу. Доступ к ресур¬су будет заблокирован до тех пор, пока один из потоков, работающих с ресур¬сом, не вызовет ReleaseSemaphore.
Вызов ReleaseSemaphore добавляет к значению счетчика семафора указанное в качестве параметра значение (обычно 1). При помощи этого же вызова можно опреде-лить значение счетчика до того, как оно было увеличено. Пример исполь¬зования сема-фора приведен в листинге 3.